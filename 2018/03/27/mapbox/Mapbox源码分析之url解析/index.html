<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mapbox源码分析之url解析 - koala&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简介:通过源码，我们来一步步分析Mapbox地图引擎如何进行指定字符串变量解析成url地址加载的，这里是基于5.3.0的版本．">
<meta property="og:type" content="article">
<meta property="og:title" content="Mapbox源码分析之url解析">
<meta property="og:url" content="http://yoursite.com/2018/03/27/mapbox/Mapbox源码分析之url解析/index.html">
<meta property="og:site_name" content="koala&#39;s Blog">
<meta property="og:description" content="简介:通过源码，我们来一步步分析Mapbox地图引擎如何进行指定字符串变量解析成url地址加载的，这里是基于5.3.0的版本．">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-04-07T14:31:51.856Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mapbox源码分析之url解析">
<meta name="twitter:description" content="简介:通过源码，我们来一步步分析Mapbox地图引擎如何进行指定字符串变量解析成url地址加载的，这里是基于5.3.0的版本．">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/webfonts/ptserif/main.css">
  <link rel="stylesheet" href="/webfonts/ptserif/source-code-pro.css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Koala</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-mapbox/Mapbox源码分析之url解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Mapbox源码分析之url解析
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/03/27/mapbox/Mapbox源码分析之url解析/" class="article-date">
  <time datetime="2018-03-27T02:20:52.000Z" itemprop="datePublished">2018-03-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/mapbox/">mapbox</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h3><p>通过源码，我们来一步步分析Mapbox地图引擎如何进行指定字符串变量解析成url地址加载的，这里是基于5.3.0的版本．<br><a id="more"></a>  </p>
<p>在官方demo中，我们不仅可以加载本地样式文件，已定义样式文件和网络在线文件，它们的格式分别是</p>
<ul>
<li>“asset://test.json”</li>
<li>“<a href="https://www.mapbox.com/android-docs/files/mapbox-raster-v8.json" target="_blank" rel="external">https://www.mapbox.com/android-docs/files/mapbox-raster-v8.json</a>“</li>
<li>“mapbox://styles/mapbox/streets-v10”<br>这些格式，那么Mapbox如果解析这些字符串去获取到需要的样式数据呢？我们从<a href="https://aaaa540188486.github.io/2018/03/26/Mapbox%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%A0%B7%E5%BC%8F%E5%8A%A0%E8%BD%BD/#more" target="_blank" rel="external">Mapbox源码分析之样式加载</a>这篇的loadURL()方法开始看起<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Style::Impl::loadURL(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; url_) &#123;</div><div class="line">    lastError = <span class="literal">nullptr</span>;</div><div class="line">    observer-&gt;onStyleLoading();</div><div class="line"></div><div class="line">    loaded = <span class="literal">false</span>;</div><div class="line">    url = url_;</div><div class="line"></div><div class="line">    styleRequest = fileSource.request(Resource::style(url), [<span class="keyword">this</span>](Response res) &#123;</div><div class="line">        <span class="comment">// Once we get a fresh style, or the style is mutated, stop revalidating.</span></div><div class="line">        <span class="keyword">if</span> (res.isFresh() || mutated) &#123;</div><div class="line">            styleRequest.reset();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Don't allow a loaded, mutated style to be overwritten with a new version.</span></div><div class="line">        <span class="keyword">if</span> (mutated &amp;&amp; loaded) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (res.error) &#123;</div><div class="line">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">"loading style failed: "</span> + res.error-&gt;message;</div><div class="line">            Log::Error(Event::Setup, message.c_str());</div><div class="line">            observer-&gt;onStyleError(<span class="built_in">std</span>::make_exception_ptr(util::StyleLoadException(message)));</div><div class="line">            observer-&gt;onResourceError(<span class="built_in">std</span>::make_exception_ptr(<span class="built_in">std</span>::runtime_error(res.error-&gt;message)));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.notModified || res.noContent) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            parse(*res.data);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>我们在这里看到，样式的数据是通过fileSource.request进行请求加载的，通过调试我们发现这个fileSource是FileSource的子类DefaultFileSource，那么我们先看看这个DefaultFileSource是什么时候传进来的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Style::Impl::Impl(Scheduler&amp; scheduler_, FileSource&amp; fileSource_, <span class="keyword">float</span> pixelRatio)</div><div class="line">    : scheduler(scheduler_),</div><div class="line">      fileSource(fileSource_),</div><div class="line">      spriteLoader(<span class="built_in">std</span>::make_unique&lt;SpriteLoader&gt;(pixelRatio)),</div><div class="line">      light(<span class="built_in">std</span>::make_unique&lt;Light&gt;()),</div><div class="line">      observer(&amp;nullObserver) &#123;</div><div class="line">    spriteLoader-&gt;setObserver(<span class="keyword">this</span>);</div><div class="line">    light-&gt;setObserver(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们在这里看到，是在构造方法时对fileSource变量进行初始化的，那么我们只需要看到Style::Impl对象什么时候构造的，便知道了fileSource的来源，继续往回找<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Style::Style(Scheduler&amp; scheduler, FileSource&amp; fileSource, <span class="keyword">float</span> pixelRatio)</div><div class="line">    : impl(<span class="built_in">std</span>::make_unique&lt;Impl&gt;(scheduler, fileSource, pixelRatio)) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里我们发现Impl对象的fileSource是Style对象构造时传进来的，那么我们继续往回找<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">style::Style&amp; Map::getStyle() &#123;</div><div class="line">    <span class="keyword">return</span> *impl-&gt;style;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Map::Impl::Impl(Map&amp; map_,</div><div class="line">                RendererFrontend&amp; frontend,</div><div class="line">                MapObserver&amp; mapObserver,</div><div class="line">                <span class="keyword">float</span> pixelRatio_,</div><div class="line">                FileSource&amp; fileSource_,</div><div class="line">                Scheduler&amp; scheduler_,</div><div class="line">                MapMode mode_,</div><div class="line">                ConstrainMode constrainMode_,</div><div class="line">                ViewportMode viewportMode_)</div><div class="line">    : <span class="built_in">map</span>(map_),</div><div class="line">      observer(mapObserver),</div><div class="line">      rendererFrontend(frontend),</div><div class="line">      fileSource(fileSource_),</div><div class="line">      scheduler(scheduler_),</div><div class="line">      transform(observer,</div><div class="line">                constrainMode_,</div><div class="line">                viewportMode_),</div><div class="line">      mode(mode_),</div><div class="line">      pixelRatio(pixelRatio_),</div><div class="line">      style(<span class="built_in">std</span>::make_unique&lt;Style&gt;(scheduler, fileSource, pixelRatio)),</div><div class="line">      annotationManager(*style) &#123;</div><div class="line"></div><div class="line">    style-&gt;impl-&gt;setObserver(<span class="keyword">this</span>);</div><div class="line">    rendererFrontend.setObserver(*<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们看到Style对象是通过map.cpp里的getStyle对象获取的，而style对象是在Map::Impl::Impl构造方法时初始化的，继续往回找<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Map::Map(RendererFrontend&amp; rendererFrontend,</div><div class="line">         MapObserver&amp; mapObserver,</div><div class="line">         <span class="keyword">const</span> Size size,</div><div class="line">         <span class="keyword">const</span> <span class="keyword">float</span> pixelRatio,</div><div class="line">         FileSource&amp; fileSource,</div><div class="line">         Scheduler&amp; scheduler,</div><div class="line">         MapMode mapMode,</div><div class="line">         ConstrainMode constrainMode,</div><div class="line">         ViewportMode viewportMode)</div><div class="line">    : impl(<span class="built_in">std</span>::make_unique&lt;Impl&gt;(*<span class="keyword">this</span>,</div><div class="line">                                  rendererFrontend,</div><div class="line">                                  mapObserver,</div><div class="line">                                  pixelRatio,</div><div class="line">                                  fileSource,</div><div class="line">                                  scheduler,</div><div class="line">                                  mapMode,</div><div class="line">                                  constrainMode,</div><div class="line">                                  viewportMode)) &#123;</div><div class="line">    impl-&gt;transform.resize(size);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们其实也能大概猜出来Map::Impl对象是在Map构造方法时初始化的，那么map对象又是什么时候初始化的，是不是觉得很绕，马上就快到了，我们找到native_map_view.cpp文件，发现在NativeMapView构造方法中构造了map对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">NativeMapView::NativeMapView(jni::JNIEnv&amp; _env,</div><div class="line">                             jni::Object&lt;NativeMapView&gt; _obj,</div><div class="line">                             jni::Object&lt;FileSource&gt; jFileSource,</div><div class="line">                             jni::Object&lt;MapRenderer&gt; jMapRenderer,</div><div class="line">                             jni::jfloat _pixelRatio)</div><div class="line">    : javaPeer(_obj.NewWeakGlobalRef(_env))</div><div class="line">    , mapRenderer(MapRenderer::getNativePeer(_env, jMapRenderer))</div><div class="line">    , pixelRatio(_pixelRatio)</div><div class="line">    , threadPool(sharedThreadPool()) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Get a reference to the JavaVM for callbacks</span></div><div class="line">    <span class="keyword">if</span> (_env.GetJavaVM(&amp;vm) &lt; <span class="number">0</span>) &#123;</div><div class="line">        _env.ExceptionDescribe();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Get native peer for file source</span></div><div class="line">    mbgl::FileSource&amp; fileSource = mbgl::android::FileSource::getDefaultFileSource(_env, jFileSource);</div><div class="line"></div><div class="line">    <span class="comment">// Create a renderer frontend</span></div><div class="line">    rendererFrontend = <span class="built_in">std</span>::make_unique&lt;AndroidRendererFrontend&gt;(mapRenderer);</div><div class="line"></div><div class="line">    <span class="comment">// Create the core map</span></div><div class="line">    <span class="built_in">map</span> = <span class="built_in">std</span>::make_unique&lt;mbgl::Map&gt;(*rendererFrontend, *<span class="keyword">this</span>,</div><div class="line">                                      mbgl::Size&#123; <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(width),</div><div class="line">                                                  <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(height) &#125;, pixelRatio,</div><div class="line">                                      fileSource, *threadPool, MapMode::Continuous,</div><div class="line">                                      ConstrainMode::HeightOnly, ViewportMode::Default);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里我们已经基本清楚fileSource的来源了，是JAVA层NativeMapView对象初始化的时候传下来的，我们继续看到开头，既然我们已经知道fileSource对象是DefaultFileSource，那么它调用的request方法，也就是调用的DefaultFileSource的request方法，这里我们看到default_file_source.cpp文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;AsyncRequest&gt; DefaultFileSource::request(<span class="keyword">const</span> Resource&amp; resource, Callback callback) &#123;</div><div class="line">    <span class="keyword">auto</span> req = <span class="built_in">std</span>::make_unique&lt;FileSourceRequest&gt;(<span class="built_in">std</span>::move(callback));</div><div class="line"></div><div class="line">    req-&gt;onCancel([fs = impl-&gt;actor(), req = req.get()] () <span class="keyword">mutable</span> &#123; fs.invoke(&amp;Impl::cancel, req); &#125;);</div><div class="line"></div><div class="line">    impl-&gt;actor().invoke(&amp;Impl::request, req.get(), resource, req-&gt;actor());</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(req);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们看到它转到了它的实现类的request方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">(AsyncRequest* req, Resource resource, ActorRef&lt;FileSourceRequest&gt; ref)</span> </span>&#123;</div><div class="line">        <span class="keyword">auto</span> callback = [ref] (<span class="keyword">const</span> Response&amp; res) <span class="keyword">mutable</span> &#123;</div><div class="line">            ref.invoke(&amp;FileSourceRequest::setResponse, res);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isAssetURL(resource.url)) &#123;</div><div class="line">            <span class="comment">//Asset request</span></div><div class="line">            tasks[req] = assetFileSource-&gt;request(resource, callback);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LocalFileSource::acceptsURL(resource.url)) &#123;</div><div class="line">            <span class="comment">//Local file request</span></div><div class="line">            tasks[req] = localFileSource-&gt;request(resource, callback);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Try the offline database</span></div><div class="line">            <span class="keyword">if</span> (resource.hasLoadingMethod(Resource::LoadingMethod::Cache)) &#123;</div><div class="line">                <span class="keyword">auto</span> offlineResponse = offlineDatabase-&gt;get(resource);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (resource.loadingMethod == Resource::LoadingMethod::CacheOnly) &#123;</div><div class="line">                    <span class="keyword">if</span> (!offlineResponse) &#123;</div><div class="line">                        <span class="comment">// Ensure there's always a response that we can send, so the caller knows that</span></div><div class="line">                        <span class="comment">// there's no optional data available in the cache, when it's the only place</span></div><div class="line">                        <span class="comment">// we're supposed to load from.</span></div><div class="line">                        offlineResponse.emplace();</div><div class="line">                        offlineResponse-&gt;noContent = <span class="literal">true</span>;</div><div class="line">                        offlineResponse-&gt;error = <span class="built_in">std</span>::make_unique&lt;Response::Error&gt;(</div><div class="line">                                Response::Error::Reason::NotFound, <span class="string">"Not found in offline database"</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!offlineResponse-&gt;isUsable()) &#123;</div><div class="line">                        <span class="comment">// Don't return resources the server requested not to show when they're stale.</span></div><div class="line">                        <span class="comment">// Even if we can't directly use the response, we may still use it to send a</span></div><div class="line">                        <span class="comment">// conditional HTTP request, which is why we're saving it above.</span></div><div class="line">                        offlineResponse-&gt;error = <span class="built_in">std</span>::make_unique&lt;Response::Error&gt;(</div><div class="line">                            Response::Error::Reason::NotFound, <span class="string">"Cached resource is unusable"</span>);</div><div class="line">                    &#125;</div><div class="line">                    callback(*offlineResponse);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offlineResponse) &#123;</div><div class="line">                    <span class="comment">// Copy over the fields so that we can use them when making a refresh request.</span></div><div class="line">                    resource.priorModified = offlineResponse-&gt;modified;</div><div class="line">                    resource.priorExpires = offlineResponse-&gt;expires;</div><div class="line">                    resource.priorEtag = offlineResponse-&gt;etag;</div><div class="line">                    resource.priorData = offlineResponse-&gt;data;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (offlineResponse-&gt;isUsable()) &#123;</div><div class="line">                        callback(*offlineResponse);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Get from the online file source</span></div><div class="line">            <span class="keyword">if</span> (resource.hasLoadingMethod(Resource::LoadingMethod::Network)) &#123;</div><div class="line">                tasks[req] = onlineFileSource.request(resource, [=] (Response onlineResponse) <span class="keyword">mutable</span> &#123;</div><div class="line">                    <span class="keyword">this</span>-&gt;offlineDatabase-&gt;put(resource, onlineResponse);</div><div class="line">                    callback(onlineResponse);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这里我们可以看到根据url的不同，和加载方法的不同，将请求分别转给了assetFileSource，localFileSource，onlineFileSource等的request方法，这里我们看onlineFileSource的request方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;AsyncRequest&gt; OnlineFileSource::request(<span class="keyword">const</span> Resource&amp; resource, Callback callback)&#123;</div><div class="line">    Resource res = resource;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (resource.kind) &#123;</div><div class="line">    <span class="keyword">case</span> Resource::Kind::Unknown:</div><div class="line">    <span class="keyword">case</span> Resource::Kind::Image:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> Resource::Kind::Style:</div><div class="line">        res.url = mbgl::util::mapbox::normalizeStyleURL(apiBaseURL, resource.url, accessToken);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> Resource::Kind::Source:</div><div class="line">        res.url = util::mapbox::normalizeSourceURL(apiBaseURL, resource.url, accessToken);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> Resource::Kind::Glyphs:</div><div class="line">        res.url = util::mapbox::normalizeGlyphsURL(apiBaseURL, resource.url, accessToken);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> Resource::Kind::SpriteImage:</div><div class="line">    <span class="keyword">case</span> Resource::Kind::SpriteJSON:</div><div class="line">        res.url = util::mapbox::normalizeSpriteURL(apiBaseURL, resource.url, accessToken);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> Resource::Kind::Tile:</div><div class="line">        res.url = util::mapbox::normalizeTileURL(apiBaseURL, resource.url, accessToken);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;OnlineFileRequest&gt;(<span class="built_in">std</span>::move(res), <span class="built_in">std</span>::move(callback), *impl);&#125;</div></pre></td></tr></table></figure></p>
<p>看到这里我们看到根据请求的类型不同，去处理不同的url,在这些参数里我们看下apiBaseURL这个变量，这是一个base url,指定了服务器地址，我们在constants.hpp文件中找到了它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constexpr const char* API_BASE_URL = &quot;https://api.mapbox.com&quot;;</div></pre></td></tr></table></figure></p>
<p>继续往下看，我们选normalizeStyleURL()方法往下看<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">normalizeStyleURL</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; baseURL,</span></span></div><div class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str,</span></span></div><div class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; accessToken)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isMapboxURL(str)) &#123;</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">const</span> URL <span class="title">url</span><span class="params">(str)</span></span>;</div><div class="line">    <span class="keyword">if</span> (!equals(str, url.domain, <span class="string">"styles"</span>)) &#123;</div><div class="line">        Log::Error(Event::ParseStyle, <span class="string">"Invalid style URL"</span>);</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> tpl = baseURL + <span class="string">"/styles/v1&#123;path&#125;?access_token="</span> + accessToken;</div><div class="line">    <span class="keyword">return</span> transformURL(tpl, str, url);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们看到它先验证了一下url,然后将url字符串包装成URL对象，然后进行一个拼接成tpl变量，最后再通过transformURL函数进行一个转换，这里我们先看它如何包装这个URL对象的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">URL::URL(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</div><div class="line">    : query([&amp;]() -&gt; Segment &#123;</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> hashPos = str.find(<span class="string">'#'</span>);</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> queryPos = str.find(<span class="string">'?'</span>);</div><div class="line">          <span class="keyword">if</span> (queryPos == <span class="built_in">std</span>::<span class="built_in">string</span>::npos || hashPos &lt; queryPos) &#123;</div><div class="line">              <span class="keyword">return</span> &#123; hashPos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos ? hashPos : str.size(), <span class="number">0</span> &#125;;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> &#123; queryPos, (hashPos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos ? hashPos : str.size()) - queryPos &#125;;</div><div class="line">      &#125;()),</div><div class="line">      scheme([&amp;]() -&gt; Segment &#123;</div><div class="line">          <span class="keyword">if</span> (str.empty() || !isAlphaCharacter(str.front())) <span class="keyword">return</span> &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</div><div class="line">          <span class="keyword">size_t</span> schemeEnd = <span class="number">0</span>;</div><div class="line">          <span class="keyword">while</span> (schemeEnd &lt; query.first &amp;&amp; isSchemeCharacter(str[schemeEnd])) ++schemeEnd;</div><div class="line">          <span class="keyword">return</span> &#123; <span class="number">0</span>, str[schemeEnd] == <span class="string">':'</span> ? schemeEnd : <span class="number">0</span> &#125;;</div><div class="line">      &#125;()),</div><div class="line">      domain([&amp;]() -&gt; Segment &#123;</div><div class="line">          <span class="keyword">auto</span> domainPos = scheme.first + scheme.second;</div><div class="line">          <span class="keyword">while</span> (domainPos &lt; query.first &amp;&amp; (str[domainPos] == <span class="string">':'</span> || str[domainPos] == <span class="string">'/'</span>)) &#123;</div><div class="line">              ++domainPos;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">const</span> <span class="keyword">bool</span> isData = str.compare(scheme.first, scheme.second, <span class="string">"data"</span>) == <span class="number">0</span>;</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> endPos = str.find(isData ? <span class="string">','</span> : <span class="string">'/'</span>, domainPos);</div><div class="line">          <span class="keyword">return</span> &#123; domainPos, <span class="built_in">std</span>::min(query.first, endPos) - domainPos &#125;;</div><div class="line">      &#125;()),</div><div class="line">      path([&amp;]() -&gt; Segment &#123;</div><div class="line">          <span class="keyword">auto</span> pathPos = domain.first + domain.second;</div><div class="line">          <span class="keyword">const</span> <span class="keyword">bool</span> isData = str.compare(scheme.first, scheme.second, <span class="string">"data"</span>) == <span class="number">0</span>;</div><div class="line">          <span class="keyword">if</span> (isData) &#123;</div><div class="line">              <span class="comment">// Skip comma</span></div><div class="line">              pathPos++;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> &#123; pathPos, query.first - pathPos &#125;;</div><div class="line">      &#125;()) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们看到它将字符串分解成query,scheme,domain,path四个变量进行存储，我们再看看transformURL()函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">transformURL</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; tpl, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="keyword">const</span> URL&amp; url)</span> </span>&#123;</div><div class="line">    <span class="keyword">auto</span> result = util::replaceTokens(tpl, [&amp;](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; token) -&gt; <span class="built_in">std</span>::<span class="built_in">string</span> &#123;</div><div class="line">        <span class="keyword">if</span> (token == <span class="string">"path"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> str.substr(url.path.first, url.path.second);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">"domain"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> str.substr(url.domain.first, url.domain.second);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">"scheme"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> str.substr(url.scheme.first, url.scheme.second);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">"directory"</span>) &#123;</div><div class="line">            <span class="keyword">const</span> Path path(str, url.path.first, url.path.second);</div><div class="line">            <span class="keyword">return</span> str.substr(path.directory.first, path.directory.second);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">"filename"</span>) &#123;</div><div class="line">            <span class="keyword">const</span> Path path(str, url.path.first, url.path.second);</div><div class="line">            <span class="keyword">return</span> str.substr(path.filename.first, path.filename.second);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">"extension"</span>) &#123;</div><div class="line">            <span class="keyword">const</span> Path path(str, url.path.first, url.path.second);</div><div class="line">            <span class="keyword">return</span> str.substr(path.extension.first, path.extension.second);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// Append the query string if it exists.</span></div><div class="line">    <span class="keyword">if</span> (url.query.second &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> amp = result.find(<span class="string">'?'</span>) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos ? result.size() : <span class="built_in">std</span>::<span class="built_in">string</span>::npos;</div><div class="line">        result.append(str, url.query.first, url.query.second);</div><div class="line">        <span class="comment">// Transform the question mark to an ampersand if we had a query string previously.</span></div><div class="line">        <span class="keyword">if</span> (amp &lt; result.size()) &#123;</div><div class="line">            result[amp] = <span class="string">'&amp;'</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们看到根据url的不同变量值进行了再次字符串拼接，甚至根据路径的不同，继续拆分成Path对象，最后将拼接结果返回，到这里有关url解析拼接的过程就讲完了．</p>

      
    </div>
    
    
      <footer class="article-footer">
        
      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/03/29/mapbox/Mapbox源码分析之发送请求/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          Mapbox源码分析之发送请求
        
      </div>
    </a>
  
  
    <a href="/2018/03/26/mapbox/Mapbox源码分析之库加载/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Mapbox源码分析之库加载&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>




<div class="share_addthis">
  <div class="sharing addthis_toolbox share">
    <a class="addthis_button_facebook_like"></a>
    <a class="addthis_button_tweet"></a>
    <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-560c64c35486b3d4" async="async"></script>
</div>




<section id="comments">
  <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC8zNDYxOS8xMTE1Nw==">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
</section>
 </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Koala&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>